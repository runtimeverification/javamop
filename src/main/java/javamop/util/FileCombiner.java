// Copyright (c) 2002-2014 JavaMOP Team. All Rights Reserved.
package javamop.util;

import javamop.JavaMOPMain;
import javamop.ParserService;
import javamop.parser.MOPException;
import javamop.parser.ast.ImportDeclaration;
import javamop.parser.ast.MOPSpecFile;
import javamop.parser.ast.PackageDeclaration;
import javamop.parser.ast.mopspec.JavaMOPSpec;

import java.io.BufferedWriter;
import java.io.File;
import java.io.FileWriter;
import java.util.ArrayList;
import java.util.List;
import java.util.Scanner;


/**
 * 
 * Helper class to combine generated intermediate AspectJ files and Processed MOP specifications.
 * 
 * @author Qingzhou Luo
 * */
public class FileCombiner {
    /**
     * Get the parser service from the JavaMOPMain.
     */
     private final static ParserService PARSER_SERVICE= JavaMOPMain.getParserService();
    /**
     * 
     * First parameter: path to java file
     * Second parameter: path to aj file
     * 
     * */

    /**
     * Combine RuntimeMonitor.java generated by RV-Monitor together with the aspectJ file
     * generated by JavaMOP. Overwrite the original aspectJ file with the combined file.
     *
     * @param args path to all the files, first parameter is the path to the java file,
     *             second parameter is the path to the aspectJ file.
     */
     public static void combineAJFiles(String[] args) {
        List<String> javaImports = new ArrayList<String>();
        List<String> ajImports = new ArrayList<String>();
        StringBuffer javaCode = new StringBuffer();
        StringBuffer ajCode = new StringBuffer();
        File javaFile = new File(args[0]);
        File ajFile = new File(args[1]);
        String pack = null;
        try {
            Scanner scanner = new Scanner(ajFile);
            while (scanner.hasNextLine()) {
                String line = scanner.nextLine();
                if (line.trim().startsWith("import")) {
                    ajImports.add(line);
                }
                else if (line.trim().startsWith("package")) {
                    pack = line;
                }
                else {
                    ajCode.append(line);
                    ajCode.append("\n");
                }
            }
            scanner.close();
            
            scanner = new Scanner(javaFile);
            while (scanner.hasNextLine()) {
                String line = scanner.nextLine();
                if (line.trim().startsWith("import")) {
                    javaImports.add(line);
                }
                else if (line.trim().startsWith("package")) {
                    pack = line;
                }
                else {
                    if (line.contains("public final class")) {
                        line = line.replace("public final class", "class");
                    }
                    javaCode.append(line);
                    javaCode.append("\n");
                }
            }
            
            List<String> combinedImports = combineList(javaImports, ajImports);
            StringBuffer results = new StringBuffer();
            if (pack != null) {
                results.append(pack);
                results.append("\n");
            }
            for (String s : combinedImports) {
                results.append(s);
                results.append("\n");
            }
            results.append(javaCode);
            results.append(ajCode);
            FileWriter fw = new FileWriter(ajFile);
            BufferedWriter bw = new BufferedWriter(fw);
            bw.write(results.toString());
            bw.flush();
            bw.close();
            scanner.close();
            fw.close();
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    /**
     * Combine multiple MOP specification files into a single one. They must all be in the same
     * package, or with some in one package and the rest with no package.
     * @param specFiles A list of specification files.
     * @return A single aggregate MOPSpecFile.
     * @throws javamop.parser.MOPException When the specification files are in conflicting packages.
     */
    public static MOPSpecFile combineSpecFiles(ArrayList<MOPSpecFile> specFiles)
            throws ParserService.MOPExceptionImpl {
        PackageDeclaration pakage = null;
        List<ImportDeclaration> imports = new ArrayList<ImportDeclaration>();
        List<JavaMOPSpec> specList = new ArrayList<JavaMOPSpec>();

        for(MOPSpecFile specFile : specFiles){
            //package decl
            PackageDeclaration pakage2 = specFile.getPakage();
            if(pakage == null)
                pakage = pakage2;
            else {
                if(!pakage2.getName().getName().equals(pakage.getName().getName()))
                    throw PARSER_SERVICE.generateMOPException
                            ("Specifications need to be in the same package to be combined.");
            }

            //imports
            List<ImportDeclaration> imports2 = specFile.getImports();

            for(ImportDeclaration imp2 : imports2){
                boolean included = false;
                for(ImportDeclaration imp : imports){
                    if(imp2.getName().getName().equals(imp.getName().getName())){
                        included = true;
                        break;
                    }
                }

                if(!included)
                    imports.add(imp2);
            }

            //specs
            List<JavaMOPSpec> specList2 = specFile.getSpecs();

            for(JavaMOPSpec spec2 : specList2){
                boolean included = false;
                for(JavaMOPSpec spec : specList){
                    if(spec2.getName().equals(spec.getName())){
                        included = true;
                        break;
                    }
                }

                if(!included)
                    specList.add(spec2);
            }
        }

        return new MOPSpecFile(0, 0, pakage, imports, specList);
    }
    
    private static List<String> combineList(List<String> one, List<String> two) {
        List<String> result = new ArrayList<String>(one);
        for (String s : two) {
            if (!result.contains(s)) {
                result.add(s);
            }
        }
        return result;
    }
}
